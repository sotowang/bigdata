# 两个进程通信方式

- 匿名管道通信
  - 管道是一种半双工的通信方式，数据只能**单向流动**，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指**父子进程关系**。
- 有名管道通信
  - 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信
- 共享内存(最高效)
  - 共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如**信号量**，配合使用，来实现进程间的同步和通信。
- 信号量
  - 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为**进程间以及同一进程内不同线程之间**的同步手段。
- 套接字
  - 套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。
- 消息队列
  - 消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点
- 信号
  - 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生

# 线程间的通信方式

- 使用全局变量
  主要由于多个线程可能更改全局变量，因此全局变量最好声明为volatile
- 使用消息实现通信
  在Windows程序设计中，每一个线程都可以拥有自己的消息队列（UI线程默认自带消息队列和消息循环，工作线程需要手动实现消息循环），因此可以采用消息进行线程间通信sendMessage,postMessage。
- 使用事件CEvent类实现线程间通信
  Event对象有两种状态：有信号和无信号，线程可以监视处于有信号状态的事件，以便在适当的时候执行对事件的操作。

# 守护进程

* 守护进程
  * 一直在后台运行的进程，独立于终端并周期性执行某种任务
  * 守护进程父进程是init进程，因它真正父进程在fork出子进程后就退出了，它是由init继承的孤儿进程
  * 常见守护进程（通常以d结尾）
    * `mysqld`
    *  `syslogd`
    *  `httpd`
    * `sshd`

## 如何创建守护进程

* 基本概念
  * 进程组（process group）
    * 一个或多个进程的集合，每个进程都有一个进程组ID，此ID为进程组长进程ID
  * 会话期(session)
    * 每个会话有唯一一个会话首进程，会话ID为会话首进程ID
  * 控制终端
    * 每个会话可有一单独控制终端，与控制终端连接的会话首进程为控制进程
* 创建流程
  * `fork()`创建子进程，父进程`exit()`退出
    * 给shell终端造成程序已运行完毕假象，之后所有工作在子进程完成，形式上与终端脱离
  * 子进程中调用`setsid()`函数创建新会话
    * `setsid（）`
      * 摆脱原会话控制，该进程成为新会话期首进程
      * 摆脱原进程组，成为一个新进程组的组长
      * 摆脱终端控制，若该进程是一进程组组长，则返回错误
  * 再次`fork()`一个子进程并让父进程退出
  * 在子进程中调用`chdir()`，让根目录“/”成为子进程工作目录
  * 在子进程中调用`unmask()`，设置进程文件权限掩码为0
  * 在子进程中关闭不需要的文件描述符
  * 守护进程退出

# 僵尸进程

* 概念
  * 进程使用`fork`创建子进程，若子进程退出而父没调用`wait()或` `waitpid`获取子进程状态信息，那么子进程进程描述符会保存在系统中
* 危害
  * 若父进程不调用`wait()`或`waitpid()`，则子进程信息不会释放，子pid被占用，而系统pid有限，导致无法产生新进程
* 解决
  * 通过kill发送SIGTERM或SIGKILL信号

# 孤儿进程

* 概念
  * 每个进程退出时，内核释放进程所有资源，但保留一定信息，如进程号，退出状态，运行时间等，当一进程完成终止后，它父进程调用`wait()`或`waitpid()`系统调用获得子进程终止状态
  * 父进程退出而子进程还在运行，子进程将成为孤儿进程，被init进程(pid为1)收养并完成对他们状态的收集工作

# fork和wait有什么作用

* fork用来创建子进程
* wait 
  * 如果子进程状态已经改变 ，wait调用立即返回；否则调用wait进程将会阻塞直到有子进程改变状态或有信号来打断
    * 状态：子进程终止；子进程被一个信号终止；子进程被一个信号恢复
  * 父进程用来等待获取子进程状态信息，获取到以后清除掉子进程



# 内零头

内零头是指进程在向操作系统请求内存分配时，系统满足了进程所需要的内存需求后，还额外还多分了一些内存给该进程，**也就是说额外多出来的这部分内存归该进程所有，其他进程是无法访问的。**

* 页式
* 请求页式

# 外零头

外零头是指内存中存在着一些空闲的内存区域，**这些内存区域虽然不归任何进程所有，但是因为内存区域太小，无法满足其他进程所申请的内存大小而形成的内存零头。**

- 段式
- 请求段式存储管理

# 用户态和内核态

## 为什么要有用户态和内核态

* 限制不同程序之间的访问能力,防止一个程序获取别的程序的内存数据,或者获取外围设备的数据

## 用户态切换到内核态

* 系统调用
* 异常
* 外围设备中断