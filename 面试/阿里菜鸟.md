# 阿里菜鸟

## 一面

```
6、进程和线程，
7、可重入锁的可重入性是什么意思，哪些是可重入锁
8、为什么要用线程池，线程池的好处
9、JVM垃圾处理方法，对象什么时候进入老年代，什么时候进行FullGC
```

### jdk1.8后对HashMap的改进

JDK7中HashMap采用的是位桶+链表的方式。而JDK8中采用的是位桶+链表/红黑树的方式，当某个位桶的链表的长度超过8的时候，这个链表就将转换成红黑树。



### 讲讲ConcurrentHashMap，ConcurrentHashMap怎么保证线程安全，HashTable怎么保证线程安全



### HashSet的底层实现，是不是线程安全的



### ArrayList和LinkedList的区别，是不是线程安全的



### 讲讲设计模式，最常用哪种设计模式，单例模式的实现方式



### Java实现多线程的方式，什么是线程安全，怎么保证多线程线程安全

#### 线程安全

* 原子性

  常用的保证Java操作原子性的工具是锁和同步方法（或者同步代码块）。使用锁，可以保证同一时间只有一个线程能拿到锁，也就保证了同一时间只有一个线程能执行申请锁和释放锁之间的代码。

* 顺序性

  Java中可通过`volatile`在一定程序上保证顺序性，另外还可以通过synchronized和锁来保证顺序性。

* 可见性

  volatile适用于不需要保证原子性，但却需要保证可见性的场景。一种典型的使用场景是用它修饰用于停止线程的状态标记



### Java堆溢出问题怎么处理，内存泄漏和内存溢出的区别

[Java堆溢出问题怎么处理，内存泄漏和内存溢出的区别](https://blog.csdn.net/sinat_35512245/article/details/54866068)

[Java内存泄漏与内存溢出详解](https://blog.csdn.net/sinat_35512245/article/details/54866068)

- 内存泄漏指你用malloc或new申请了一块内存，但是没有通过free或delete将内存释放，导致这块内存一直处于占用状态。
- 内存溢出指你申请了10个字节的空间，但是你在这个空间写入11或以上字节的数据，就是溢出。

内存泄露是指程序中间动态分配了内存，但在程序结束时没有释放这部分内存，从而造成那部分内存不可用的情况，重启计算机可以解决，但也有可能再次发生内存泄露，内存泄露和硬件没有关系，它是由软件设计缺陷引起的。

内存泄漏可以分为4类： 

- 1)常发性内存泄漏。

- 2)偶发性内存泄漏。

- 3)一次性内存泄漏。

- 4)隐式内存泄漏。

内存溢出即用户在对其数据缓冲区操作时，超过了其缓冲区的边界；尤其是对缓冲区写操作时，缓冲区的溢出很可能导致程序的异常。

看到上面的解释，可能有些朋友还是不太理解吧。没问题，看以下例子:

- 1.Java内存泄露是说程序逻辑问题,造成申请的内存无法释放.这样的话无论多少内存,早晚都会被占用光的. 最简单的例子就是死循环了.由于程序判断错误导经常发生此事。
- 2.Java内存泄漏是指在堆上分配的内存没有被释放，从而失去对其控制。这样会造成程序能使用的内存越来越少，导致系统运行速度减慢，严重情况会使程序当掉。
- 3.关于内存溢出有点出入。比如说你申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。

### Java对象池技术

[Java对象池技术](https://www.jianshu.com/p/38c5bccf892f)

#### 为什么用对象池

在 java 中，对象的生命周期包括对象创建、对象使用，对象消失三个时间段，其中对象的使用是对象真正需要存活的时间，不好修改，该用的时候还得使用啊。对象的创建和消失就得好好控制下了。对象的创建是比较费时间的，也许感觉不到，好比一个赋值操作int i=1，也是需要耗时的，在比如构造一个对象，一个数组就更加消耗时间。再说对象的消除，在 java 里面使用 GC 来进行对象回收，其实也是需要对对象监控每一个运行状态，包括引用，赋值等。在 Full GC 的时候，会暂停其他操作，独占 CPU。所以，我们需要控制对象的创建数量，也不要轻易的让对象消失，让他的复用更加充分。

### 对象池

对象池其实就是一个集合，里面包含了我们需要的对象集合，当然这些对象都被池化了，也就是被对象池所管理，想要这样的对象，从池子里取个就行，但是用完得归还。对象池的对象最好是创建比较费时的大对象，如果是太简单的对象，再进入池化的时间比自己构建还多，就不划算了。可以理解对象池为单例模式的延展，多例模式，就那么几个对象实例，再多没有了。

书上说这个模式会用在数据库连接的管理上。比如，每个用户的连接数是有限的，这样每个连接就是一个池子里的一个对象，“连接池”类就可以控制连接数了。

### 自定义一个低质量的对象池

首先构造一个池化对象，也就是对实际对象封装下,为什么呢？当然是为了让对象池更好的管理

```java
public  class PooledObject<T> {

 private T objection = null;// 外界使用的对象
 private boolean busy = false; // 此对象是否正在使用的标志，默认没有正在使用

 // 构造函数，池化对象
 public PooledObject(T objection) {
  this.objection = objection;
 }

 // 返回此对象中的对象
 public T getObject() {
  return objection;
 }

 // 设置此对象的，对象
 public void setObject(T objection) {
  this.objection = objection;
 }

 // 获得对象对象是否忙
 public boolean isBusy() {
  return busy;
 }

 // 设置对象的对象正在忙
 public void setBusy(boolean busy) {
  this.busy = busy;
 }
}
```



池化对象现在包括两个属性，一个是原始对象的引用，另外一个表示当前对象是否在使用

接下来把对象池写出来

## 二面：

```
1、讲讲数据库存储引擎
2、介绍一下索引，索引设置的规则，聚簇索引和非聚簇索引的区别，索引的最左前缀原则
3、用过redis吗，redis支持哪些数据类型，redis与mysql的区别
4、了解垃圾收集器吗，分别介绍介绍
5、jvm调优做过没，-Xms和-Xmx分别指什么
6、算法题：输入两个字符串，输出它们合并排序后的结果
```

## 三面：

```
1、讲讲数据库的范式
2、Linux进程通信和线程通信
3、线程池的参数
4、什么是内部类，什么是匿名内部类
5、设计题：一个市有9个消防站，现在要新增3个消防站，这3个消防站应该放在哪里
```

------

### Java线程池实例解析

[Java线程池实例解析](https://blog.csdn.net/qq_33142257/article/details/75968791)

#### 线程池概念：

首先，要理解什么是线程池；还是先拿具体例子来说，这个例子可能比较偏了，因为现实生活中接触的少了，但是比较能形象的阐述线程池的含义；

> 摆渡，在科技不发达的时候，没有能力造那种大桥，人们过河只能通过码头的船夫摆渡到对岸；为了更贴切，我说的这个码头就只做摆渡的生意，其他运输之类的不干；码头的船则是码头的老板创业时自己造的；

> 理解上述的背景后，这样我们就可以拿两者来开始类比了；码头就相当于线程池，而码头里的船就是每一条线程；为什么这样说呢，船其实是一个载体，需要执行的任务其实是过河这个动作，线程也是这样，它也是个载体，完成具体的方法是任务；首先假想一个场景，一个书生到了河边要到对岸去（ps：不管他会不会游泳，还是会飞；这里限定他只能通过船这个途径）；那他只有两种选择，第一个是自己造船，第二个是坐码头里摆渡的船；这两种方式不管是哪个都是完成过河的任务，但是你会发现，码头的船很多，当书生坐上船走后，后面又来了几个人也要过河，他们能立马就载上这几个人；

> 码头是船的集合，那么线程池就是线程的集合；为什么要弄出个线程池出来呢，差异就显而易见了，码头的船在客户来之前就已经造好放在那儿等待使用，而如果没有码头的话，客户来到这儿要过河只能自己造船，然后才能过河；这是其一，一个要建造船，一个不要，线程池也是这样，如果没有线程池的话，那么某个方法中要使用多线程的时候，需要new一个线程，而线程池则不一样了，当需要使用线程的时候直接去线程池中取一个，省去了创建线程这个环节，提高效率；

> 还有就是多个人需要过河，码头有很多船则会大大的提高效率，不仅省去了造船的环节还省去了资源的占用，如果是每个人自己造船的话，岸边的树估计要被砍光了；多个任务需要执行的时候，手动创建线程会占用太多内存资源，而且每个都需要new，浪费了时间；

好了，其实上述的例子已经把线程池以及它的优点都基本表达出来了，但是还是要结合代码具体讲解下，才能更清楚理解；

#### 线程池

创建一个线程集合，池子的大小取决于内存数量；当需要执行一个任务的时候是重用一个等待的线程，而不是重新开启一个线程；当任务执行完成后继续回到池子中等待下一个任务
优点：

```
1、减少在创建和销毁线程上所花的时间和资源开销
2、与主线程隔离，实现异步执行
```

注意：池中的线程数不是越多越好，线程休眠同样也会占用资源，所以要合理的选择线程池大小

#### 线程池的几个实例

基础类：

```java
import java.text.SimpleDateFormat;
import java.util.Date;
 
/**
 * Created by zelei.fan on 2017/6/13.
 */
public class ThreadHandle implements Runnable{
 
    private String index;
 
    ThreadHandle(String index){
        this.index = index;
    }
 
    @Override
    public void run() {
        SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        Date date = new Date();
        String time = df.format(date);
        System.out.println(Thread.currentThread().getName()+"Start Time"+time);
        /*中间一段处理时间*/
        try {
            Thread.sleep(4000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        Date date1 = new Date();
        String time1 = df.format(date1);
        System.out.println(Thread.currentThread().getName()+"End Time"+time1);
    }
}
```

- 1、Executors.newCachedThreadPool()；可缓存的线程池，当线程越多线程池规模也随之扩大,默认超时时间是60s，如果超过会自动终止该线程

```
public static void main(String[] args) {
        /*newCachedThreadPool可缓存线程池同时启动了5个线程来执行*/
        ExecutorService pool = Executors.newCachedThreadPool();
        for (int i = 0; i < 5; i ++){
            pool.execute(new ThreadHandle(String.valueOf(i)));
        }
    }

```

运行结果：

```
pool-1-thread-3Start Time2017-07-24 13:35:28
pool-1-thread-1Start Time2017-07-24 13:35:28
pool-1-thread-5Start Time2017-07-24 13:35:28
pool-1-thread-4Start Time2017-07-24 13:35:28
pool-1-thread-2Start Time2017-07-24 13:35:28
pool-1-thread-2End Time2017-07-24 13:35:32
pool-1-thread-3End Time2017-07-24 13:35:32
pool-1-thread-4End Time2017-07-24 13:35:32
pool-1-thread-1End Time2017-07-24 13:35:32
pool-1-thread-5End Time2017-07-24 13:35:32
```

可以看到线程池同时启动了5个线程来执行任务，理论上可开启的线程数是无限的，但是受cpu的影响，cpu越多的话开的越多；

- 2、Executors.newFixedThreadPool(2)；创建一个固定大小的线程池；当线程达到最大数时，大小不再变化，适用于固定的稳定的并发编程

```java
public static void main(String[] args) {
        /*newFixedThreadPool固定线程数的线程池同一时刻最多只开启设定的5个线程，只有当前面的线程结束后才会继续执行后面等待的任务*/
        ExecutorService executorService = Executors.newFixedThreadPool(2);
        for (int i = 0; i < 6; i ++){
            executorService.execute(new ThreadHandle(String.valueOf(i)));
        }
    }

```

运行结果：

```
pool-1-thread-2Start Time2017-07-24 13:42:04
pool-1-thread-1Start Time2017-07-24 13:42:04
pool-1-thread-1End Time2017-07-24 13:42:08
pool-1-thread-2End Time2017-07-24 13:42:08
pool-1-thread-1Start Time2017-07-24 13:42:08
pool-1-thread-2Start Time2017-07-24 13:42:08
pool-1-thread-1End Time2017-07-24 13:42:12
pool-1-thread-2End Time2017-07-24 13:42:12
pool-1-thread-1Start Time2017-07-24 13:42:12
pool-1-thread-2Start Time2017-07-24 13:42:12
pool-1-thread-2End Time2017-07-24 13:42:16
pool-1-thread-1End Time2017-07-24 13:42:16
```

同时开启是个任务来执行，但是线程池大小只有2，一个时间点只能有两个线程并行，其余的任务则必须等待，直到上一个任务执行完成；

- 3、Executors.newSingleThreadExecutor()；创建一个单线程，串行执行

```
public static void main(String[] args) {
        /*newSingleThreadExecutor单线程,同一时刻只有一个线程实例，所有任务都用这个实例执行
        * 相当于Executors.newFixedThreadPool(1)；
        * */
        ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();
        for (int i = 0; i < 5; i ++){
            singleThreadExecutor.execute(new ThreadHandle(String.valueOf(i)));
        }
    }

```

运行结果：

```
pool-1-thread-1Start Time2017-07-24 13:46:07
pool-1-thread-1End Time2017-07-24 13:46:11
pool-1-thread-1Start Time2017-07-24 13:46:11
pool-1-thread-1End Time2017-07-24 13:46:15
pool-1-thread-1Start Time2017-07-24 13:46:15
pool-1-thread-1End Time2017-07-24 13:46:19
pool-1-thread-1Start Time2017-07-24 13:46:19
pool-1-thread-1End Time2017-07-24 13:46:23
pool-1-thread-1Start Time2017-07-24 13:46:23
pool-1-thread-1End Time2017-07-24 13:46:27
```

上述结果中至始至终就只有一个线程thread-1在运行；

- 4、Executors.newScheduledThreadPool(5)；计划类线程池

1）、延时执行：

```java
public static void main(String[] args) {
        /*计划类线程池*/
        ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(5);
        for (int i = 0; i < 5; i ++){
            /*延时10秒执行*/
            scheduledExecutorService.schedule(new ThreadHandle(String.valueOf(i)), 10, TimeUnit.SECONDS);
        }
        SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        Date date = new Date();
        String time = df.format(date);
        System.out.println(time);
    }

```

打印结果：

```
2017-07-24 13:54:10
pool-1-thread-2Start Time2017-07-24 13:54:20
pool-1-thread-3Start Time2017-07-24 13:54:20
pool-1-thread-1Start Time2017-07-24 13:54:20
pool-1-thread-4Start Time2017-07-24 13:54:20
pool-1-thread-5Start Time2017-07-24 13:54:20
pool-1-thread-3End Time2017-07-24 13:54:24
pool-1-thread-2End Time2017-07-24 13:54:24
pool-1-thread-4End Time2017-07-24 13:54:24
pool-1-thread-1End Time2017-07-24 13:54:24
pool-1-thread-5End Time2017-07-24 13:54:24
```

可以看到线程在十秒之后才开始执行；

2）、间断执行：



```java
public static void main(String[] args) {
        /*计划类线程池*/
        ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(5);
        for (int i = 0; i < 5; i ++){
            /*从0ms开始每隔10秒执行一个任务，需要注意的是这个时间间隔是从上一个线程开始时计算的*/
            scheduledExecutorService.scheduleAtFixedRate(new ThreadHandle(String.valueOf(i)), 0, 10, TimeUnit.SECONDS);
        }
    }

```

打印结果：

线程每次开始于上一次开始间隔都是10s，而且会无限的执行下去，类似于定时任务；



3）、间断执行:

```
public static void main(String[] args) {
        /*计划类线程池*/
        ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(5);
        for (int i = 0; i < 5; i ++){
            /*从0ms开始每隔10秒执行一个任务，需要注意的是这个时间间隔是从上一个线程结束后计算的*/
            scheduledExecutorService.scheduleWithFixedDelay(new ThreadHandle(String.valueOf(i)), 0, 10, TimeUnit.SECONDS);
        }
    }

```

打印结果：

上面结果是每次线程和上一次线程执行结束后间隔10s；



#### 多线程回调：

基础类：

```
import java.util.concurrent.Callable;
 
/**
 * Created by zelei.fan on 2017/6/13.
 */
public class CallableTest implements Callable<String> {
 
    private int index;
 
    public CallableTest(int index){
        this.index = index;
    }
 
    @Override
    public String call() throws Exception {
        System.out.println("call()方法被自动调用, 开始*******" + Thread.currentThread().getName());
        if(index > 5){
            Thread.sleep(1000);
        }else {
            Thread.sleep(10000);
        }
        return "call()方法被自动调用，结束*******" + Thread.currentThread().getName();
    }
}

```

submit：将线程放入线程池中，除了使用execute，还可以使用submit,而且能够获取回调，submit适用于生产者-消费者模式，和Future一起使用起到没有返回结果就阻塞当前线程，等待线程池返回结果；



```java
public static void main(String[] args) {
        ExecutorService pool1 = Executors.newCachedThreadPool();
        List<Future<String>> futureList = Lists.newArrayList();
        for (int i = 0; i < 5; i ++){
            Future<String> future = pool1.submit(new CallableTest(i));
            futureList.add(future);
        }
        futureList.forEach(new Consumer<Future<String>>() {
            @Override
            public void accept(Future<String> stringFuture) {
                try {
                    System.out.println(stringFuture.get());
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (ExecutionException e) {
                    e.printStackTrace();
                }
            }
        });
    }

```

打印结果：

调用结束打印的语句都是在run方法中返回出来的，通过future来接受返回参数，然后将future打印；

说到回调，还有一种就是CompletionService，区别是future是阻塞的，而CompletionService是异步非阻塞的；
看下具体例子：

```java
public static void main(String[] args) {
        ExecutorService pool1 = Executors.newCachedThreadPool();
        CompletionService service = new ExecutorCompletionService(pool1);
        for (int i = 0; i < 10; i ++){
            service.submit(new CallableTest(i));
        }
        for(int i = 0; i < 10; i ++){
            try {
                SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
                Date date = new Date();
                String time = df.format(date);
                System.out.println(service.take().get() + time);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } catch (ExecutionException e) {
                e.printStackTrace();
            }
        }
    }

```

打印结果：



通过上面一个例子可以知道Future是阻塞取出结果的，按顺序执行，如果说正常的前面的线程执行完成后面的线程还在执行中的话，前面线程的结果时可以直接返回的，但是如果后面的线程比前面的线程先执行完成，则后面线程的返回结果需要等待前面线程返回后才能取得结果； 而CompletionService是异步非阻塞的，哪个执行完成有回调了，哪个就能输出结果；





