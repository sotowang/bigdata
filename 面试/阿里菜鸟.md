# 阿里菜鸟

## 一面

### jdk1.8后对HashMap的改进

JDK7中HashMap采用的是位桶+链表的方式。而JDK8中采用的是位桶+链表/红黑树的方式，当某个位桶的链表的长度超过8的时候，这个链表就将转换成红黑树。

### 讲讲ConcurrentHashMap，ConcurrentHashMap怎么保证线程安全，HashTable怎么保证线程安全



### HashSet的底层实现，是不是线程安全的



### ArrayList和LinkedList的区别，是不是线程安全的



### 讲讲设计模式，最常用哪种设计模式，单例模式的实现方式



### 可重入锁的可重入性是什么意思，哪些是可重入锁(递归锁)

意味着线程可以进入它已经拥有的锁的同步代码块儿。

在JAVA环境下 ReentrantLock 和synchronized 都是 可重入锁



### Java实现多线程的方式，什么是线程安全，怎么保证多线程线程安全

#### 线程安全

* 原子性

  常用的保证Java操作原子性的工具是锁和同步方法（或者同步代码块）。使用锁，可以保证同一时间只有一个线程能拿到锁，也就保证了同一时间只有一个线程能执行申请锁和释放锁之间的代码。

* 顺序性

  Java中可通过`volatile`在一定程序上保证顺序性，另外还可以通过synchronized和锁来保证顺序性。

* 可见性

  volatile适用于不需要保证原子性，但却需要保证可见性的场景。一种典型的使用场景是用它修饰用于停止线程的状态标记



### Java堆溢出问题怎么处理，内存泄漏和内存溢出的区别

[Java堆溢出问题怎么处理，内存泄漏和内存溢出的区别](https://blog.csdn.net/sinat_35512245/article/details/54866068)

[Java内存泄漏与内存溢出详解](https://blog.csdn.net/sinat_35512245/article/details/54866068)

- 内存泄漏指你用malloc或new申请了一块内存，但是没有通过free或delete将内存释放，导致这块内存一直处于占用状态。
- 内存溢出指你申请了10个字节的空间，但是你在这个空间写入11或以上字节的数据，就是溢出。

内存泄露是指程序中间动态分配了内存，但在程序结束时没有释放这部分内存，从而造成那部分内存不可用的情况，重启计算机可以解决，但也有可能再次发生内存泄露，内存泄露和硬件没有关系，它是由软件设计缺陷引起的。

内存泄漏可以分为4类： 

- 1)常发性内存泄漏。

- 2)偶发性内存泄漏。

- 3)一次性内存泄漏。

- 4)隐式内存泄漏。

### 为什么要用线程池，线程池的好处





### Java对象池技术

[Java对象池技术](https://www.jianshu.com/p/38c5bccf892f)

#### 为什么用对象池

在 java 中，对象的生命周期包括对象创建、对象使用，对象消失三个时间段，对象的创建是比较费时间的，也许感觉不到，好比一个赋值操作int i=1，也是需要耗时的，在比如构造一个对象，一个数组就更加消耗时间。再说对象的消除，在 java 里面使用 GC 来进行对象回收，其实也是需要对对象监控每一个运行状态，包括引用，赋值等。**在 Full GC 的时候，会暂停其他操作，独占 CPU。**所以，我们需要控制对象的创建数量，也不要轻易的让对象消失，让他的复用更加充分。

### 对象池

想要这样的对象，从池子里取个就行，但是用完得归还。**对象池的对象最好是创建比较费时的大对象**，如果是太简单的对象，再进入池化的时间比自己构建还多，就不划算了。可以理解对象池为单例模式的延展，多例模式，就那么几个对象实例，再多没有了。

书上说这个模式会用在数据库连接的管理上。比如，每个用户的连接数是有限的，**这样每个连接就是一个池子里的一个对象，“连接池”类就可以控制连接数了。**

### 自定义一个低质量的对象池

首先构造一个池化对象，也就是对实际对象封装下,为什么呢？当然是为了让对象池更好的管理

```java
public  class PooledObject<T> {

 private T objection = null;// 外界使用的对象
 private boolean busy = false; // 此对象是否正在使用的标志，默认没有正在使用

 // 构造函数，池化对象
 public PooledObject(T objection) {
  this.objection = objection;
 }

 // 返回此对象中的对象
 public T getObject() {
  return objection;
 }

 // 设置此对象的，对象
 public void setObject(T objection) {
  this.objection = objection;
 }

 // 获得对象对象是否忙
 public boolean isBusy() {
  return busy;
 }

 // 设置对象的对象正在忙
 public void setBusy(boolean busy) {
  this.busy = busy;
 }
}
```

池化对象现在包括两个属性，一个是原始对象的引用，另外一个表示当前对象是否在使用

### JVM垃圾处理方法

•  **标记-清除算法**

–标记阶段：先通过根节点，标记所有从根节点开始的对象，未被标记的为垃圾对象。

–清除阶段：清除所有未被标记的对象。

• **复制算法**

–将原有的内存空间分为两块，每次只使用其中一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中，然后清除正在使用的内存块中的所有对象。

• **标记-整理算法**

–标记阶段：先通过根节点，标记所有从根节点开始的可达对象，为被标记的为垃圾对象

–整理阶段：将所有的存活对象压缩到内存的一段，之后清理边界所有的空间



• 三种算法的比较 ：
• 效率：复制算法 > 标记/整理算法 > 标记/清除算法（此处的效率只是简单的对比时间复杂度，实际情况不一定如此）。
• 内存整齐度：复制算法=标记/整理算法>标记/清除算法。

• 内存利用率：标记/整理算法=标记/清除算法>复制算法。

### 对象什么时候进入老年代

(1)当对象首次创建时, 会放在新生代的eden区, 若没有GC的介入，会一直在eden区, **GC后**，是可能进入survivor区或者年老代

(2)当对象**年龄达到一定的大小** ,就会离开年轻代， 进入老年代。 而对象的年龄是由GC的次数决定的

-XX:MaxTenuringThreshold=n　　新生代的对象最多经历n次GC， 就能晋升到老年代, 但不是必要条件 　　

-XX:TargetSurvivorRatio=n　　用于设置Survivor区的目标使用率，即当survivor区GC后使用率超过这个值, 就可能会使用较小的年龄作为晋升年龄

(3)除年龄外, 对象体积也会影响对象的晋升的, 若对象体积太大, 新生代无法容纳这个对象

-XX:PretenureSizeThreshold　　即对象的大小大于此值, 就会绕过新生代, 直接在老年代分配, 此参数只对串行回收器以及ParNew回收有效, 而对ParallelGC回收器无效

### 什么时候进行FullGC

1. System.gc()方法的调用 

system.gc(), 此方法的调用是建议JVM进行Full GC, 可通过通过-XX:+ DisableExplicitGC来禁止RMI调用System.gc。 

2. old/Tenured 空间不足 

老年代空间在新生代对象转入及创建为大对象、大数组时

当执行Full GC后空间仍然不足，报错：java.lang.OutOfMemoryError: Java heap space 

```
java -Xmx10m -Xms10m -Xmn10m -XX:+UseParNewGC  -XX:+UseConcMarkSweepGC -XX:+UseCMSInitiatingOccupancyOnly  -XX:CMSInitiatingOccupancyFraction=75 -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintHeapAtGC gc.ConcurrentMarkSweep 
```

3. perm/metaspace 空间不足
4.  CMS GC时出现promotion failed和concurrent mode failure  
5. 判断当前新生代的对象是否能够全部顺利的晋升到老年代，如果不能，就提早触发一次老年代的收集

## 二面

```
1、讲讲数据库存储引擎
2、介绍一下索引，索引设置的规则，聚簇索引和非聚簇索引的区别，索引的最左前缀原则
3、用过redis吗，redis支持哪些数据类型，redis与mysql的区别
4、了解垃圾收集器吗，分别介绍介绍
6、算法题：输入两个字符串，输出它们合并排序后的结果
```

### -Xms和-Xmx分别指什么

-xms 初始堆大小

-xmx 最大堆大小







## 三面：

```
1、讲讲数据库的范式
2、Linux进程通信和线程通信
3、线程池的参数
4、什么是内部类，什么是匿名内部类
5、设计题：一个市有9个消防站，现在要新增3个消防站，这3个消防站应该放在哪里
```

------

### Java线程池实例解析

[Java线程池实例解析](https://blog.csdn.net/qq_33142257/article/details/75968791)

#### 线程池概念：

如果没有线程池的话，那么某个方法中要使用多线程的时候，需要new一个线程，而线程池则不一样了，当需要使用线程的时候直接去线程池中取一个，省去了创建线程这个环节，提高效率；多个任务需要执行的时候，手动创建线程会占用太多内存资源，而且每个都需要new，浪费了时间；

**创建一个线程集合，池子的大小取决于内存数量；当需要执行一个任务的时候是重用一个等待的线程，而不是重新开启一个线程；当任务执行完成后继续回到池子中等待下一个任务**

* 优点：

```
1、减少在创建和销毁线程上所花的时间和资源开销
2、与主线程隔离，实现异步执行
```

注意：**池中的线程数不是越多越好，线程休眠同样也会占用资源，所以要合理的选择线程池大小**

- 1、Executors.newCachedThreadPool()；可缓存的线程池，当线程越多线程池规模也随之扩大,默认超时时间是60s，如果超过会自动终止该线程

运行结果：

可以看到线程池同时启动了5个线程来执行任务，理论上可开启的线程数是无限的，但是受cpu的影响，cpu越多的话开的越多；

- 2、Executors.newFixedThreadPool(2)；创建一个固定大小的线程池；当线程达到最大数时，大小不再变化，适用于固定的稳定的并发编程

运行结果：

同时开启是个任务来执行，但是线程池大小只有2，一个时间点只能有两个线程并行，其余的任务则必须等待，直到上一个任务执行完成；

- 3、Executors.newSingleThreadExecutor()；创建一个单线程，串行执行

上述结果中至始至终就只有一个线程thread-1在运行；

- 4、Executors.newScheduledThreadPool(5)；计划类线程池

1）、延时执行：

可以看到线程在十秒之后才开始执行；

2）、间断执行：

线程每次开始于上一次开始间隔都是10s，而且会无限的执行下去，类似于定时任务；

3）、间断执行:

上面结果是每次线程和上一次线程执行结束后间隔10s；



#### 多线程回调：

基础类：

```java
import java.util.concurrent.Callable;
 
/**
 * Created by zelei.fan on 2017/6/13.
 */
public class CallableTest implements Callable<String> {
 
    private int index;
 
    public CallableTest(int index){
        this.index = index;
    }
 
    @Override
    public String call() throws Exception {
        System.out.println("call()方法被自动调用, 开始*******" + Thread.currentThread().getName());
        if(index > 5){
            Thread.sleep(1000);
        }else {
            Thread.sleep(10000);
        }
        return "call()方法被自动调用，结束*******" + Thread.currentThread().getName();
    }
}

```

submit：将线程放入线程池中，除了使用execute，还可以使用submit,而且能够获取回调，submit适用于生产者-消费者模式，和Future一起使用起到没有返回结果就阻塞当前线程，等待线程池返回结果；



```java
public static void main(String[] args) {
        ExecutorService pool1 = Executors.newCachedThreadPool();
        List<Future<String>> futureList = Lists.newArrayList();
        for (int i = 0; i < 5; i ++){
            Future<String> future = pool1.submit(new CallableTest(i));
            futureList.add(future);
        }
        futureList.forEach(new Consumer<Future<String>>() {
            @Override
            public void accept(Future<String> stringFuture) {
                try {
                    System.out.println(stringFuture.get());
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (ExecutionException e) {
                    e.printStackTrace();
                }
            }
        });
    }

```

打印结果：

调用结束打印的语句都是在run方法中返回出来的，通过future来接受返回参数，然后将future打印；

说到回调，还有一种就是CompletionService，区别是future是阻塞的，而CompletionService是异步非阻塞的；
看下具体例子：

```java
public static void main(String[] args) {
        ExecutorService pool1 = Executors.newCachedThreadPool();
        CompletionService service = new ExecutorCompletionService(pool1);
        for (int i = 0; i < 10; i ++){
            service.submit(new CallableTest(i));
        }
        for(int i = 0; i < 10; i ++){
            try {
                SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
                Date date = new Date();
                String time = df.format(date);
                System.out.println(service.take().get() + time);
            } catch (InterruptedException e) {
                e.printStackTrace();
            } catch (ExecutionException e) {
                e.printStackTrace();
            }
        }
    }

```

打印结果：

通过上面一个例子可以知道Future是阻塞取出结果的，按顺序执行，如果说正常的前面的线程执行完成后面的线程还在执行中的话，前面线程的结果时可以直接返回的，但是如果后面的线程比前面的线程先执行完成，则后面线程的返回结果需要等待前面线程返回后才能取得结果； 而CompletionService是异步非阻塞的，哪个执行完成有回调了，哪个就能输出结果；





