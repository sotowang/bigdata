# Java特性

## 封装

* 隐藏对象的属性和实现细节，仅对外公开接口,控制在程序中属性的读和修改的访问级别。

## 继承

* 实现代码的复用。

##  多态

> 同一种事物表现出的多种形态。

* 多态的实现方式
  * 基于继承实现的多态

  * 基于接口实现的多态

  * 多态的存在有三个前提
    * 要有继承关系 
    	 子类要重写((override))父类的方法	
    * 父类引用指向子类对象
* 多态性主要表现在如下两个方面:

  * 方法重载
    * 通常指在同一个类中,相同的方法名对应着不同的方法实现,但是方法的参数不同.
  * 成员覆盖
    * 通常指在不同类(父类和子类)中,允许有相同的变量名,但是数据类型不同;也允许有相同的方法名，但是对应的方法实现不同.
* 多态的好处

  * 程序的可扩展性及可维护性增强。
* 成员变量

  * 编译和运行都参考左边。
* 成员函数（非静态）

  * 编译看左边，运行看右边
* 静态函数
  * 编译和运行都看左边。
* 项目中多态的应用
  * 在物流管理系统中,有两个用户有不同的权限,但使用相同的login方法登陆后会进入到不同的页面

# Java对象创建过程

类加载检查-->分配内存-->初始化零值-->设置对象头-->执行init方法

# 访问修饰符作用域

| 访问级别 | 访问控制修饰符 | 同类 | 同包 | 子类 | 不同包 |
| :------: | :------------: | :--: | :--: | :--: | :----: |
|   公开   |     public     |  √   |  √   |  √   |   √    |
|  受保护  |   protected    |  √   |  √   |  √   |        |
|   默认   |    default     |  √   |  √   |      |        |
|   私有   |    private     |  √   |      |      |        |



# Java对象在内存中布局

* 对象头
  * 实现Synchronized锁对象基础
  * 2个机器码(32位是8字节)存储对象头,如果是数组,则为3机器(12字节)码,多出来一个记录数组长度
* 实例数据
  * 类属性信息,包括父类属性信息
  * 若数组的实例部分要包括数组的长度
  * 4字节对齐
* 对齐填充
  * 虚拟机要求对象起始地址为8字节整数倍
  * 填充数据不是必须存在

# List,Set,Collection,Collections

1.List和Set都是接口，他们都继承于接口Collection,List是一个有序的可重复的集合，而Set的无序的不可重复的集合。Collection是集合的顶层接口，Collections是一个封装了众多关于集合操作的静态方法的工具类,因为构造方法是私有的，所以不能实例化。

2.List接口实现类有ArrayList,LinkedList,Vector。ArrayList和Vector是基于数组实现的,所以查询的时候速度快，而在进行增加和删除的时候速度较慢LinkedList是基于链式存储结构，所以在进行查询的时候速度较慢但在进行增加和删除的时候速度较快。又因为Vector是线程安全的，所以他和ArrayList相比而言，查询效率要低。

# 创建对象的方式

* 使用new

* Class类的newInstance方法

  * `newInstance()`调用无参构造器（反射）

  * `Class.forName().newInstance()`

    ```java
    User user = User.class.newInstance();
    User user = (User)Class.forName("根路径.User").newInstance();
    ```

* 使用Constructor类的`newInstance()`方法

  ```java
  Constructor<User> constructor = User.class.getConstructor();
  User user = constructor.newInstance();
  ```

* 使用`clone()`

  * 需要先实现Cloneable接口并实现`clone方法`

* 反序列化

  * 需实现Serializable接口
  * 序列化和反序列化对象时，JVM会创建一个单独对象。
  * 反序列化时，JVM创建对象不会调用任何构造函数

# 类的实例化顺序

* 加载类

  1. 为父类静态属性分配内存并赋值 / 执行父类静态代码段 （按代码顺序）

  2. 为子类静态属性分配内存并赋值 / 执行子类静态代码段 （按代码顺序）
* 创建对象

  1. 为父类实例属性分配内存并赋值 / 执行父类非静态代码段 （按代码顺序）
  2. 执行父类构造器
  3. 为子类实例属性分配内存并赋值 / 执行子类非静态代码段 （按代码顺序）
  4. 执行子类构造器  


# 重写(override)与重载(overload)

* 重写

  * 重写是子类对父类的允许访问的方法的实现过程进行重新编写,
  * 返回值和形参都不能改变。
  * **即外壳不变，核心重写！**

* 重载

  * 在一个类里面，**方法名字相同，而参数不同**。返回类型可以相同也可以不同。
  * 每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。
  * 最常用的地方就是构造器的重载。

* 重载规则

  - 被重载的方法**必须改变参数列表**(参数个数或类型不一样)；
  - 被重载的方法可以改变返回类型；
  - 被重载的方法可以改变访问修饰符；
  - 被重载的方法可以声明新的或更广的检查异常；
  - 方法能够在同一个类中或者在一个子类中被重载。
  - 无法以返回值类型作为重载函数的区分标准。

* 重写与重载的区别

  | 区别点     | 重载方法              | 重写方法                                       |
  | :--------- | :-------------------- | ---------------------------------------------- |
  | 参数列表   | 必须修改              | 一定不能修改                                   |
  | 返回类型   | 可以修改              | 一定不能修改                                   |
  | 异常       | 可以修改              | 可以减少或删除，一定不能抛出新的或者更广的异常 |
  | 访问修饰符 | 可以修改              | 一定不能做更严格的限制（可以降低限制）         |
| 发生时机   | 同一类中,或继承关系中 | 子类与父类之间                                 |
  
  ![img](https://www.runoob.com/wp-content/uploads/2013/12/20171102-1.jpg)

## 是否可以重写Private或Static方法

* static方法不能被重写
  * 重写是基于运行时绑定的,而static方法是编译时绑定
  * static方法跟类的实例不相关,概念上不适用
* private方法不可重写
  * private修饰的变量和方法只能在当前类中使用
  * 若其他类继承当前类则无法访问到private方法

# 运算符优先级

单目运算符：+，-，++，--

算数运算符：+，-，*，/，%

移位运算符：<<,>>

关系运算符：>,<,>=,<=,==,!=

位运算符：&，|，~，^,

逻辑运算符：&&，||

三目运算符：表达式1？表达式2：表达式3;

赋值运算符：=等

 

# switch

switch 语句中的变量类型可以是：

 byte、short、int 或者 char。

从 Java SE 7 开始，switch 支持字符串 String 类型了，同时 case 标签必须为字符串常量或字面量。



# equals与hashCode()

- 若两对象相同equals返回true,则hashCode值必相同
- 若两对象hashCode相同,equals可能为false
- hashCode
  - 对象比较时先进行hashCode比较.若不同,则没有后序比较必要.减少了equals比较次数,效率提高
  - 集合中的例子
    - set集合不重复且无序,在插入时会判断是否重复,若用equals则全都要比较一遍,使用hash表大大减少比较的次数
- 为何必须重写hashCode
  - equals根据对象的特征重写的
  - 保证同一对象在equals相同时hashCode必相同

# ==与equals的区别

* equals由开发者自己写逻辑,默认为==
* String重写了equals,比较字符是否相同
* ==判断两个判断是否或实例是不是指向同一个内存空间
* equals判断两个变量或实例所指向的内存空间的值是否相同
* 基本数据类型用==比较的是值
* `StringBuffer` 和`StringBuilder`特殊.==和equals都是比较地址

# sleep和wait的区别

![](https://pic2.zhimg.com/80/bb4f380c79779c9dc1aea6f0a6c10b6d_hd.jpg)

* sleep让线程阻塞,特定时间后转为非阻塞,重新获得CPU
* wait调用时先获得该Object的锁,调用wait后将锁释放并阻塞.当调用notify/notifyAll后,可能获得CPU重新获得锁

# [Clone()](https://segmentfault.com/a/1190000010648514)

* 声明为`protected Object clone() CloneNotSupportedException`
* 无论浅拷贝还是深拷贝,都需要实现clone()方法以及`Cloneable`接口来完成操作
* 浅拷贝
  * 对基本数据类型进行值传递,对引用数据类型进行引用传递
* 深拷贝
  * 对基本数据类型进行值传递,对引用数据类型,创建一个新的对象,并复制其内容
  * 实现方案
    * 序列化`serialization`这个对象,再反序列化回来,就可以得到新的对象
    * 利用`clone()`,对其内的引用类型的变量再进行一次`clone()`

* 如果一个**对象内部只有基本数据类型**，那用 clone() 方法获取到的就是这个对象的**深拷贝**，而**如果其内部还有引用数据类型，那用 clone() 方法就是一次浅拷贝的操作**。

  
    

# static

* static方法是否能被覆盖
  * 不能，因方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的
* 是否可在static中访问非static变量
  * 不能，Static属于类，在类加载时就被初始化，此时非静态变量未被加载
* static 修饰的变量并发下怎么保证变量的安全
  * 静态变量位于方法区，为所有对象共享，修改对其他对象可见，非线程安全
  * 静态方法若无使用静态变量，则无线程安全问题
    * 因静态方法内声明的变量，每个线程调用时都会创建一份，而不会可使用一个存储单元
  * 加锁
* static 修饰的变量什么时候赋值
* static 什么时候使用

# 序列化

* 定义
  * 将实现Serializable接口的对象转换成一个字节序列，并在以后恢复成原来的对象，序列化可以弥补不同操作系统之间差异
* 作用
  * Java远程方法调用RMI
  * 对Java Beans进行序列化

## 如何实现序列化与反序列化

* 序列化
  * 实现Serializable接口
    * 若不改变方法中`readObject()`和`writeObject()`方法，则采取默认序列化机制
    * 可使用`transient`关键字修饰不必序列化的属性
  * 实现`ExternalSerializable`接口
    * 自己要对序列化内容进行控制，控制那些属性能被序列化
* 反序列化
  * 不需调用构造方法，完全基于字节
  * 实现`ExternalSerializable`接口的方法在反序列化时会调用构造方法
* 注
  * 被static修饰属性不会序列化
  * 父类实现序列化子类自动实现
  * 方法不会被序列化(只保存对象(不是类,因为static属性)的状态,不保存对象的方法)
  * 通过网络，文件序列化时，必须按照写入的顺序读取对象
  * 反序列化时须有序列化对象的class文件
  * 最好显示声明serializableID,因不同JVM间，默认生成serializableID可能不同
  * 当一个对象的实例变量引用其他变量时,序列化该对象时也要把其他对象序列化
  * 并非所有对象都可以序列化
    * 安全原因,在对象序列化过程中,private等域不受保护
      * 资源分配原因,如socket,thread类,如果可以序列化进行传输或者保存,也无法对它们进行资源重新分配
* 序列化前和后对象关系是equal关系，深复制(拷贝)

# [Comparable接口与Comparator接口区别](https://cloud.tencent.com/developer/article/1118794)

* Comparable接口
  * 需要修改源码,在源码中实现`compareTo() `方法,是一个内比较器
* Comparator接口
  * 不用修改源码,实现`compare()`方法,一个外比较器