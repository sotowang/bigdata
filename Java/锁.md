# 悲观锁

> 传统的关系型数据库里面:行锁,表锁,写锁,都是在做操作之前先上锁.
>
> synchronized和RenentrantLock等独占锁是悲观锁的体现 
>
> 适用于多写



# 乐观锁

> 拿数据的时候不会上锁,更新时会判断有没别人更新数据.数据库的write_condition机制
>
> 可以使用版本号机制和CAS算法实现
>
> 适用于多读,提高吞吐量

* 版本号机制

  * 取出记录时获取当前version

  * 更新时带上这个version

  * 执行更新时

    ```sql
    set version = newVersion where version = oldVersion
    ```

  * 如果version不对,更新失败

    ```sql
    update table set name = 'Aron', version = version + 1 where id = #{id} and version = #{version};
    ```

* CAS算法

  * 包含三个操作数--内存位置（V），预期原值（A），新值（B）
  * 缺点
    * 若循环时间长，则开销很大
    * 只能保证一个共享变量的原子操作
      * 解决 :JDK1.5后,AtomicReference类,保证引用对象之间的原子性,把多个共享变量合并为一个共享变量操作
    * ABA 问题 
      * 解决：AtomicStampedReference,其中的compareAndSet方法就是首先检查当前引用是否等于预期引用,并且当前标志是否等于预期标志,如果全部相等,则以原子方式将该引用和该标志的值设置为给定的更新值

# 自旋锁

- 许多情况下，共享数据的锁定状态持续时间较短，切换线程不值得
- 通过让线程执行忙循环等待锁的释放，不让出CPU
- 缺点：若锁被其他线程长时间占用，会带来许多性能上的开销

# 自适应自旋锁

- 自旋的次数不再固定
- 由前一次在同一个锁一的自旋时间及锁的拥有者的状态来决定

# 锁消除

# 锁粗化

- 通过扩大加锁范围，避免频繁加锁

# 公平锁

- 获取锁的顺序按先后调用lock方法的顺序

# 非公平锁

- 抢占的顺序不一定

# 可重入锁

> 递归锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁（前提得是同一个对象或者class）

ReentrantLock和synchronized都是可重入锁

# 不可重入锁

> 若当前线程执行某个方法已经获取了该锁，那么在方法中尝试再次获取锁时，就会获取不到被阻塞。

不可重入锁，与可重入锁相反，不可递归调用，递归调用就发生死锁。

看到一个经典的讲解，使用自旋锁来模拟一个不可重入锁，代码如下：

```java
import java.util.concurrent.atomic.AtomicReference;

public class UnreentrantLock {

    private AtomicReference<Thread> owner = new AtomicReference<Thread>();

    public void lock() {
        Thread current = Thread.currentThread();
        //这句是很经典的“自旋”语法，AtomicInteger中也有
        for (;;) {
            if (!owner.compareAndSet(null, current)) {
                return;
            }
        }
    }

    public void unlock() {
        Thread current = Thread.currentThread();
        owner.compareAndSet(current, null);
    }
}

```

在执行每次操作之前，判断当前锁持有者是否是当前对象，采用state计数，不用每次去释放锁。

# Synchronized实现原理

# ReentrantLock实现原理

# sychronized锁

## 获取的锁的分类

* 获取对象锁
  * 同步代码块（synchronized(this), synchorized(类实例对象)）。锁是小括号（）中的实例对象
  * 同步方法（synchronized method）,锁是当前对象的实例对象。
* 获取类锁
  * 同步代码块（synchrinized（类.class）），锁是小括号中的类对象（Class对象）
  * 同步静态方法（synchronized static method），锁的是当前对象的类对象（Class对象）
* 对象锁和类锁
  * 有线程访问对象的同步代码块时，另外的线程可以访问该对象的非同步代码地块
  * 若锁住的是同一个对象，一个线程在访问对象的同步代码块时，另一个访问对象的同步代码块时会被阻塞
  * 若锁住的是同一个对象，一个线程在访问对象的同步方法时，另一个访问对象同步方法的线程会被阻塞
  * 若锁住的是同一个对象，一个线程在访问对象的同步代码块时，另一个访问对象同步方法的线程会被阻塞，反之亦然；
  * 同一个类的不同对象的对象锁， 互不干扰
  * 类锁由于也是一种特殊的对象锁，因此表现和上述1，2，3，4一致，而由于一个类只有一把对象锁，所以同一个类的不同对象使用类锁将会是同步的；
  * 类锁和对象锁互不干扰

## sychronized的四种状态

* 无锁
* 偏向锁
  * 减少同一线程获取锁的代价
  * 大多数情况下，锁不存在多线程竞争，总是由同一线程多次获得
  * 不适应于锁竞争比较激烈的多线程场合
* 轻量级锁
  * 由偏向锁升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁急用的时候，偏向锁就会升级为轻量级锁
  * 适用场景：线程交替执行同步块
* 重量级锁

**锁膨胀方向：**

​	无锁-> 偏向锁->轻量级锁->重量级锁



# synchronized和ReentrantLock区别

* 公平锁

  * ReentrantLock公平性的设置

    ```java
    //参数为true时，倾向于将锁赋予等待时间最久的线程
    ReentrantLock fairLock = new  ReentrantLock(true);
    ```

  * synchronized是非公平锁

* synchronized是关键字，RenentrantLock是类

  * synchronized在JVM层面实现,可通过监控工具监控synchronized的锁定,代码异常时,JVM自动释放锁
  * lock需要显示加锁,释放锁

* RenentrantLock可以获取各种锁的信息

* 对获取锁的等待时间进行设置，避免死锁

  * 感知有没有成功获取锁
  * 判断是否有线程，或者某个特定线程，在排队等待获取锁

* RenentrantLock可以灵活地实现多路通知

* 机制：sync操作Mark Word，lock和Unsafe类的park()方法

# volatile和synchronized的区别

|          | synchronized                                                 | volatile                                                  |
| -------- | ------------------------------------------------------------ | --------------------------------------------------------- |
| 本质     | 锁定变量，只有当前线程可以访问该变量，其他线程被阻塞住直到该线程完成变量操作 | 告诉JVM变量在寄存器（工作内存）中的值不确定，需从主存读取 |
| 范围     | 变量,类,方法                                                 | 变量                                                      |
| 功能     | 原子性, 可见性                                               | 可见性                                                    |
| 线程阻塞 | 会                                                           | 不会                                                      |
| 编译优化 | 会                                                           | 不会                                                      |

# volatile与普通变量区别

* 普通变量
  * 读操作优先读取工作内存中的数据,若工作内存不存在,则从主内存copy一份至工作内存
  * 写操作时只修改工作内存中副本数据 ,此时其它线程无法读取变量最新值
* volatile变量
  * 读操作时JMM把工作内存中对应值设置无效,要求从主内存读数据
  * 写操作时JMM把工作内存中数据刷新到主内存,其它线程就可以读取变量最新值

# volatile禁止重排优化

* 内存屏障(Memory Barrier)
  * 保证特定操作的执行顺序
  * 保证某些变量的内存可见性
* 通过插入内存屏障指令禁止在内存屏幕前后的指令执行重排序优化
* 强制刷出各种CPU的缓存数据,因此任何CPU上的线程都能读取到这些数据的最新版本

# volatile使用场景

*　对变量的写操作不依赖当前值
  *　如多线程下执行a++，是无法通过volatile保证结果准确性的
*　该变量没有包含在具有其他变量的不变式中
*　访问变量不需要加锁

# 锁和synchronized为何能保证可见性？

根据[JDK 7的Java doc](http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/package-summary.html#MemoryVisibility)中对`concurrent`包的说明，一个线程的写结果保证对另外线程的读操作可见，只要该写操作可以由`happen-before`原则推断出在读操作之前发生。

> The results of a write by one thread are guaranteed to be **visible** to a read by another thread only if the write operation happens-before the read operation. The synchronized and volatile constructs, as well as the Thread.start() and Thread.join() methods, can form happens-before relationships.

# 为何还要volatile保证可见性

**synchronized和锁需要通过操作系统来仲裁谁获得锁**，开销比较高，而volatile开销小很多。

因此在只需要保证可见性的条件下，使用volatile的性能要比使用锁和synchronized高得多。

# 为何还要AtomicInteger保证原子操作

锁和synchronized需要通过操作系统来仲裁谁获得锁，开销比较高，而AtomicInteger是通过CPU级的CAS操作来保证原子性，开销比较小。

使用AtomicInteger的目的还是为了提高性能。

# 别的办法保证线程安全

有。尽可能避免引起非线程安全的条件——**共享变量**。如果能从设计上避免共享变量的使用，即可避免非线程安全的发生，也就无须通过锁或者synchronized以及volatile解决原子性、可见性和顺序性的问题。



