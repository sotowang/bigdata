# 判断对象是否为垃圾

* 引用计数算法	

  * 通过判断对象的引用数量来决定对象是否可以被回收
  * 每个对象实例都有一个引用计数器，被引用则+1，完成引用则-1
  * 任何引用计数为0的对象实例可以被当作垃圾收集

* 可达性分析算法

  * 通过判断对象的引用链是否可达来决定对象是否可以被回收


## [可以作为GC Root的对象](https://www.jianshu.com/p/4a1080373096)

   * 虚拟机栈中引用的对象（栈帧中的本地变量表）换句话说，**当前所有正在被调用的方法的引用类型的参数/局部变量/临时值**。
   * 方法区中的常量引用的对象
   *  方法区中的类静态属性引用的对象
 * 本地方法栈中JNI的引用对象   
   
* 活跃线程的引用对象

# 垃圾回收算法

* 标记-清除算法

  * 标记
    * 从根集合进行扫描，对存活的对象进行标记
  * 清除
    * 对堆内存从头到尾进行遍历，回收不可达对象内存

  **不足**

  * 碎片化

* 复制算法（年轻代适用）

  * 分为对象面和空闲面
  * 对象在对象面上创建
  * 存活的对象被从对象面复制到空闲面
  * 将对象面所有对象内存清除

  **优点**

  * 解决碎片化问题
  * 顺序分配内存，简单高效
  * 适用于对象存活率低的场景

* 标记-整理算法

  * 标记
    * 从根集合进行招描，对存活的对象进行标记
  * 清除
    * 移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收

* 分代收集算法

  * 垃圾回收算法的组合拳
  * 按照对象生命周期的不同划分区域以采用不同的垃圾回收算法
  * 目的：提高JVM的回收效率
  * 分类

    * Minor GC
    * Full GC
  * 新生代(1/3)
    * Eden区(8)
    * 两个Survior(1,1)
  * 老年代(2/3)
  * 常用调优参数
    * -XX:SurvivorRatio
      * Eden和Survivor比值,默认8:1
    * -XX:NewRatio
      * 老年代和新生代的内存大小比例
    * -XX:MaxTenuringThreshold
      * 对象从年轻代晋升到老年代经过GC次数的最大阈值

  

# [触发Minor GC条件](https://blog.csdn.net/qq_23410909/article/details/90211521)

* Eden(伊甸园)空间不足。

# [触发Full GC的条件](https://blog.csdn.net/qq_23410909/article/details/90211521)

* 老年代空间不足
* 永久代(JDK 8已无)空间不足
* CMS GC时出现promotion failed,concurrent mode failure
* Minor GC晋升到老年代的平均大小大于老年代的剩余空间
* 调用`System.gc()`
* 使用RMI来进行RPC或管理JDK应用,每小时执行一次FullGC

# Stop the World

* JVM 由于要执行GC而停止了应用程序的执行
* 任何一GC算法中都会发生
* 多数GC优化通过减少Stop-the-world发生的时间来提高程序的性能

# 垃圾收集器

* 种类
  * 串行Serial
    * 单线程垃圾回收
  * 并行Parallel(java8默认)
    * 多个垃圾回收线程并行工作
  * 并发标记（CMS）
    * 用户线程与垃圾收集线程同时执行（不一定并行，可交替），不需用户暂停，适用对响应时间有要求的场景
  * G1(java1.9 默认)
    * 将堆内存分割，并发回收，不会产生碎片
    * `-XX:+UseG1GC`,复制+标记-整理算法
    * `stop the world`可控，用户可指定期望时间，增加预测机制
* 查看垃圾收集器
  * `-XX：+printCommandLineFlags -version`

## 年轻代收集器

* Serial收集器
  * `-XX:+UseSerialGC`,复制算法
  * 单线程收集,进行垃圾收集时,必须暂停所有工作线程
  * 简单高效,Client模式下默认的年轻代收集器
* ParNew收集器
  * `-XX:+UseParNewGC`,复制算法
  * 多线程收集器,其余的行为,特点和Serial收集器一样
  * 单核执行效率不如Serial,在多核下执行才有优势
* Parallel Scavenge收集器(1.8默认)
  *  `-XX:+UseParallelGC`,复制算法
  * 吞吐量=运行用户代码时间/(运行用户代码时间+地方都用收集时间)
  * 比起关注用户线程停顿时间,更关注系统的吞吐量
  * 在多核下执行才有优势,Server模式下默认的年轻代收集器

## 老年代收集器

* Serial Old收集器
  * `-XX:+UseSerialOldGC`,标记-整理算法
  * 单线程收集,进行垃圾收集时,必须暂停所有工作线程
  * 简单高效,Client模式下默认的老年代收集器
* Parallel Old收集器(1.8默认)
  * `-XX:+UseParallelOldGC`,标记-整理算法
  * 多线程,吞吐量优先

### [CMS收集器](https://juejin.im/post/6844903974676463629#comment)

  * `-XX:+UseConcMarkSweepGC`,标记-清除算法
  * **初始标记**
      * stop-the-world(很快)
      * **初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快**
  * 并发标记
      * 并发追溯标记,程序不会停顿
  * **重新标记**
      * 修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录.**这个阶段的停顿时间一般会比初始阶段稍长一些，但远比并发标记的时间短**
      * stop the world
  * 并发清理
      * 清理垃圾对象,程序不会停顿

| 优点 | 并发收集,停顿低                                              |
| ---- | ------------------------------------------------------------ |
| 缺点 | 会导致大量碎片    对CPU资源压力大                            |
|      | 标记-清除算法将产生大量的内存碎片这对新生代来说是难以接受的，因此**新生代的收集器并未提供CMS版本** |

* 安全点
  * **程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停**。Safepoint的选定既不能太少以至于让GC等待时间太长，也不能过于频繁以致于过分增大运行时的负荷。

## [G1垃圾收集器](https://juejin.im/post/6844903974676463629#comment)

* 核心思想
  
  * 将整个堆内存区域划分成大小相同的子区域(Region),在JVM启动时会自动设置这些子区域大小(1-32M)
  * 目的是在进行收集时不必在全堆范围内进行
  * 区域划分的好处就是带来了停顿时间可预测的收集模型：用户可以指定收集操作在多长时间内完成。即G1提供了接近实时的收集特性。
* **初始标记(STW)**
* 这个阶段是STW(Stop the World )的，所有应用线程会被暂停，标记出从GC Root开始直接可达的对象。
* 并发标记
* 从GC Roots开始对堆中对象进行可达性分析，找出存活对象，耗时较长。当并发标记完成后，开始最终标记(Final Marking )阶段
* **最终标记(STW)**
* 标记那些在并发标记阶段发生变化的对象，将被回收
* **筛选回收(STW)**
  * 首先对各个Region的回收价值和成本进行排序，根据用户所期待的GC停顿时间指定回收计划，回收一部分Region

| 优点 | **可以看到最后一步G1是停顿的而CMS不会停顿，这也是CMS会产生浮动垃圾的原因** |      |
| ---- | ------------------------------------------------------------ | ---- |
|      | G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短Stop-the-world停顿的时间，部分其他收集器原来需要停顿Java线程执行的GC操作，G1收集器仍然可以通过**并发**的方式让Java程序继续运行。 |      |
|      | 更精确预测GC停顿时间                                         |      |
|      | G1不会产生内存碎片                                           |      |

# finalize()方法

* Object的protected方法，子类可以覆盖以实现资源清理工作，**GC在回收对象之前调用该方法**,如果内存充足,则该方法可能永远不会被调用
* 主要用途是回收特殊渠道的内存(一般情况下有GC不用程序员操心)
  * 可用来清理本地对象JNI(Java Native Interface)调用非Java程序
* 确保某非内存资源释放的一个补充，在finalize方法中显示调用其他资源释放方法
* 对象再生
  * 将待回收对象赋值给GC Roots可达的对象引用，从而达到再生
* 至多由GC执行一次

# 强引用/软引用/弱引用/虚引用

* 强引用

  * 最普遍的引用
    * `Object obj = new Object()`
  * 抛出OutOfMemoryError终止程序也不会回收具有强引用的对象
  * 通过将对象是设置为null来弱化引用,使其被回收

* 软引用

    * 对象处在有用但非必须的状态

    * 只有当内存空间不足时,GC会回收该内存

    * 可以用来实现高速缓存

      ```java
      String str = new String("abc") //强引用
      SoftReference<String> softRef = new SoftReference<String>(str); //软引用
      ```

* 弱引用

  * 非必须的引用,比软引用更弱一些

  * GC时会被回收

  * 被回收的概率也不大,因为GC线程优先级比较低

  * 适用于引用偶尔被使用且不影响垃圾收集的对象

    ```java
    String str = new String("abc");
    WeakReference<String> abcWeakRef = new WeakReference<String>(str)
    ```

* 虚引用

  * 不会决定对象的生命周期
  * 任何时候都可能被垃圾收集器回收
  * 跟踪对象被垃圾收集器回收的活动,起哨兵作用
  * 必须和引用队列ReferenceQueue联合使用,被回收时对象将被放到引用队列中保存

  ```java
  String str = new String("abc");
  ReferenceQueue queue = new ReferenceQueue();
  PhantomReference ref = new PhantomReference(str,queue);
  ```

  | 引用类型 | 被垃圾回收时间 | 用途           | 生存时间          |
  | -------- | -------------- | -------------- | ----------------- |
  | 强引用   | 从来不会       | 对象的一般状态 | JVM停止运行时终止 |
  | 软引用   | 在内存不足时   | 对象缓存       | 内存不足时终止    |
  | 弱引用   | 在垃圾回收时   | 对象缓存       | gc运行后终止      |
  | 虚引用   | Unknow         | 标记,哨兵      | Unknown           |

  

