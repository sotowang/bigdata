# 单例模式

对于一个软件系统中的某些类而言，只有一个实例很重要，例如一个系统只能有一个窗口管理器或文件系统，一个系统只能有一个计时工具或ID（序号）生成器等。

如果不使用机制对窗口对象进行唯一化，势必会弹出多个窗口。如果这些窗口显示的内容完全一致，则是重复对象，浪费内存资源。如果这些窗口显示的不一致，则意味着在某一瞬间系统有多个状态，与实际不符，也会给用户带来误解，不知道哪一个才是真实的状态。

- 优缺点

  - 确保全局至多只有一个对象
  - 用于:构造缓慢的对象,需要统一管理资源
  - 缺点: 很多全局状态,线程安全性

- 单例模式的创建

  - 双重锁模式 Double checked locking
  - 作为Java类的静态变量
  - 使用框架提供的能力

- 饿汉式

  ```java
  public class Singleton{
      private static Singleton instance = new Singleton();
      private Singleton(){}
      public static Singleton getInstance(){
          return instance;
      }
  }
  ```

* 懒汉式

  ```java
  //DCL模式（Double Check Lock双端检锁机制）
  public class Singleton{
      
      //加volatile是因为防止指令重排
      //memory = allocate(); //1.分配对象内存空间
      //instance(memory); //2.初始化对象
      //instance = memory; //3.设置instance指向刚分配的内存地址,此时Instance ！=null，但instance还未完成初始化
      private static volatile Singleton instance;
      private Singleton(){}
      public static Singleton getInstance(){
          if(null == instance){
              synchronized(Singleton.class){
                  if(null == instance){
                      instance = new Singleton();
                  }
              }
          }
          return instance;
      }
  }
  ```

  

  

## 单例在多线程中的运行问题？

单例分为饿汉式和懒汉式，如果在多线程中调用单例模式，获取对象的时候，如果使用的是饿汉式，不存在线程的安全问题。如果是懒汉式，那就存在线程的安全问题，需要使用同步进行处理。



# 状态模式



# 策略模式

定义一系列算法，将每一个算法封装起来，并让他们可以相互替换。策略模式让算法可以铁立于使用它的客户而变化

票价打折案例



# 迭代器模式

提供一种方法顺序访问一个聚合对象中的各个元素，成果又不用暴露该对象的内部表示

JDK中的Colloction



# 装饰器模式

动态地给一个对象增加一些客外的职责。就扩展功能而言，装饰器模式提供了一种比使用子类更加灵活的替代方案

Java I/O 输入流，输出流的设计，javax.swing包中一些图形界面构件功能的增强等地方都用了装饰模式。

* （扩展一个对象的功能，装饰模式比继承更加灵活，不会导致类的个数急剧增加）
* 可以对一个对象进行多次装饰，通过使用不同的具体装饰类以及这些装饰类的排列组合可以创造出很多种不同行为和组合，得到功以能更强大的对象
* 具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，原有类库代码无须改变，符合开闭原则。

# 观察者模式

* 定义对象之间的一种一对多的信赖关系，便得每当一个对象状态发生改变时其相关依赖对象皆得到通知并被动更新。
* 别名：  发布订阅模式，源-监听器模式，从属者模式
* MVC应用



# 简单工厂模式

# 工厂方法模式

# 代理模式

* 代购案例
* 给某个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问
* 在代理模式中引入了一个新的代理对象，代理对象地客户端和目标对象之间起到中介的作用，它去掉客户不能看到的内容和服务或者增添客户需要的额外的新服务。
* 远程代理
* 虚拟代理
* 动态代理 （事务管理  AOP）

# 模板方法模式

* 请客吃饭案例

模板方法模式是基于继承的代码复用技术，它体现了面向对象的诸多重要思想，是一种使用较为频繁的设计模式。模板方法模式广泛应用于框架设计（例如：Spring，JUnit等）中，以确保通过父类来控制处理流程的逻辑顺序（例如框架的寝化，测试流程和设置等）





# 享元模式

当系统中存在大量相同或者相似的对象时，享元模式是一种值得考虑的解决方案，它通过共享技术实现相同或相似的细粒度对象的利用，从而节约了内存空间，提高了系统性能。

* 围棋案例
* String类使用了享元模式



# 组合模式

组合模式又称为“部分-整体模式”，属于对象结构型模式，它将对象组织到树形结构中，可以用来描述整体与部分的关系。

组合模式通过一种巧妙的设计方案使得用户可以一致性地处理整个树形结构或者树形结构的一部分，它描述了如何将容器对象和叶子对象进行递归组合，使得用户在使用时无须对它们进行区分，可以一致地对待容器对象和叶子对象，这就是组合模式的模式动机。

* 实例说明

  ```
  某软件公司要开发一个杀毒软件，该软件既可以对某个文件夹杀毒，也可以对某个指定的文件杀毒。该杀毒软件还可以根据各类文件的特点为不同类型的文件提供不同的杀毒方式，例如图像文件和文本文件的杀毒方式说有所差异。现使用组合模式来设计该杀毒软件的整体构架。
  ```

  

* 透明组合模式

* 安全组合模式



# 命令模式

可以将开关理解成一个请求的发送者，用户通过它来发送一个“开灯”的请求，而电灯是“开灯请求”的最终接收者和处理者，开关和电灯之间并不存在直接耦合关系，它们通过电线连接在一起，使用不同的电线可以连接不同的请求接收者，只需更换一根电线，相同的发送者（开关）即可对应不同的接收者（电器）

* 实例说明

```
为了用户使用方便，某系统提供了一系列功能键，用户可以自定义功能键的功能，例如功能键FunctionButton可以用于退出系统（由SystenExitClass类来实现），也可以用于显示帮助文档（由DisplayHelpClass类来实现）

用户可以通过修改配置文件改变功能键的用途，现使用命令模式设计该系统，使得功能键类与功能类之间解耦。可以为同一个功能键设置不同和功能。
```

# 解释器模式

解释器模式用于描述如何构成一个简单的语言解释器，主要用于使用面向对象语言开发的解释器的设计。当需要开发一个新的语言时可以考虑使用解释器模式。在实际应用中也许很少碰到构造一个语言的情况，虽然很少使用，但是对它的学习能够加深对面向对象思想的理解，并且掌握编程语言中语法规则解释的原理和过程。







