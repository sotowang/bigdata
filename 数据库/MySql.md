# MySQL 索引

* 索引的原理

  * 对要查询的字段建立索引==>**把该字段按照一定的方式排序**；
  * 建立的索引只对该字段有用，如果查询的字段改变，那么这个索引也就无效
  * 还有就是如果索引太多会降低查询的速度
* 优点

  * 查询时就会先去索引列表中一次定位到特定值的行数大大减少遍历匹配的行数，增加查询的速度。
* 缺点
  * 全表查询情况,索引无意义
  * 对非唯一的字段，例如“性别”这种大量重复值的字段，增加索引也没有什么意义。
  * 索引是需要存储空间, 对于记录比较少的表，增加索引不会带来速度的优化反而浪费了存储空间，
  * 对于update/insert/delete的每次执行，字段的索引都必须重新计算更新。所以并不是任何情况下都改建立索引的

## **哪些列适合建立索引**

* 经常需要搜索的列
* 在**作为主键的列**上，强制该列的唯一性和组织表中数据的排列结构。
* 经常用在连接的列上，这些列主要是**外键**，**可以加快连接速度。** 
* 经常需要**根据范围进行搜索的列**上创建索引，因为索引已经排序，所以其指定的范围是连续的。
* 经常需要排列的列，因为索引已经排序，这样可以利用索引的排序，**加快查询的速度。** 
* **经常需要使用WHERE子句**，**加快条件的判断速度。**

## MySQL里的索引类型

* B-Tree索引

  * 最常见的索引类型，基于B-Tree数据结构
  * B-Tree的基本思想是，所有值（被索引的列）都是排过序的，每个叶节点到跟节点距离相等。
  * B-Tree适合用来查找某一范围内的数据，而且可以直接支持数据排序（ORDER BY）。但是当索引多列时，列的顺序特别重要，需要格外注意。
  * InnoDB和MyISAM都支持B-Tree索引。InnoDB用的是一个变种B+Tree，而MyISAM为了节省空间对索引进行了压缩，从而牺牲了性能。

* Hash索引

  基于hash表。所以这种索引只支持精确查找，不支持范围查找，不支持排序。

* Full-Text
* R-Tree



# InnoDB

* 若一个主键被定义，该主键则作为密集索引
* 若没有主键被定义，该表的第一个唯一非空索引则作为密集索引
* 若不满足以上条件，innodb内部会生成一个隐藏主键（密集索引）
* 索引和数据存在一块
* 有且只有一个密集索引
* 支持事务

# MyISAM

* 索引和数据分开存储
* 不管是主键索引，唯一键索引还是普通索引都是稀疏索引
* 不支持事务

# MySQL 查询优化

* MySQL逻辑架构

  ![img](http://dbaplus.cn/uploadfile/2017/0928/20170928110355446.png)

  * 客户端层
    * 并非MySQL所独有
    * 连接处理
    * 授权认证
    * 安全
  * 核心服务
    * 查询解析
    * 分析
    * 优化
    * 缓存
    * 内置函数
  * 存储引擎
    * 数据存储
    * 数据提取

* MySQL查询过程

  ![img](http://dbaplus.cn/uploadfile/2017/0928/20170928110411496.jpg)

  - 客户端向MySQL服务器发送一条查询请求
  - 服务器首先检查查询缓存，如果命中缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段
  - 服务器进行SQL解析、预处理、再由优化器生成对应的执行计划
  - MySQL根据执行计划，调用存储引擎的API来执行查询
  - 将结果返回给客户端，同时缓存查询结果

* 避免向数据库请求不需要的数据

  * 使用LIMIT
  * 避免使用select *

* 查询数据的方式

  * 通过EXPLAIN语句中的type列反应查询的是哪种方式
  * 通过添加合适的索引改善查询数据的方式,使其尽可能减少扫描的数据行,加快查询速度

* 分解大的查询

  * 将大查询分解为多个小查询,每个小查询只完成整个查询任务的一小部分,每次只返回一小部分结果
  * 优点:
    * 缓存效率高
    * 减少锁竞争
    * 更容易对数据库进行拆分,更容易做到高性能和可扩展
    * 查询本身的效率也可能有提升

* 优化MIN()和MAX()

  * 添加索引,B-Tree

*  用IN() 取代OR

  * IN()先将自己列表中折数据进行排序,然后通过二分查找的方式确定列的值是是否在IN()的列表中,时间复杂度O(logn)
  * OR操作,时间复杂度为O(n)

* 优化关联查询

  * 