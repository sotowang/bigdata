# 如何设计一个关系型数据库

* RDBMS  
  * 程序实例
    * 存储管理
    * 缓存机制
    * SQL解析
    * 日志管理
    * 权限划分
    * 容灾机制
    * **索引管理**
    * **锁管理**
  *  存储（文件系统）

# 索引模块

## 为什么要使用索引

* 避免全表扫描查找数据，提升查找效率

## 什么样的信息能成为索引？

* 主键，唯一键，普通键等让数据具备一定区分性的字段

## 索引的数据结构

* 二叉查找树
* B-Tree
  * 根节点至少包括两个孩子
  * 树中每个节点最多包含有m个孩子（m>=2）
  * 除根节点和叶节点外，其他每个节点至少有ceil(m/2)个孩子
  * 所有叶子节点都在同一层
* B+-Tree（Mysql）
  * 非叶子节点的子树指针与关键字个数相同
  * 非叶子节点的子树指针P[i],指向关键字值[K[i],K[i+1]]的子树
  * 非叶子节点仅用来索引，叶子节点存储数据
  * 所有叶子节点均有一个指针链接到下一个叶子节点
* Hash
  * 仅能满足“=”，“IN”，不能使用范围查询
  * 无法被用来避免数据的排序操作
  * 不能利用部分索引键查询
  * 不能避免表扫描
  * 遇到大量Hash值相等的情况后性能并不一定比B树索引高
* BitMap索引

## 密集索引和稀疏索引的区别

* 密集索引文件中的每个搜索码值都对应一个索引值
* 稀疏索引文件只为索引码的某些值建立索引项

## 如何定位并优化慢查询Sql

* 根据慢日志定位慢查询sql
* 使用explain等工具分析sql
* 修改sql或者尽量让sql走索引

## 联合索引的最左匹配原则的成因

* 最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询（>,<,between,like）就停止匹配，比如a=3 and b=4 and c>5 and d=6 如果建立（a,b,c,d）顺序的索引，d是用不到索引的，如果建立（a,b,d,c）的索引，则都可以用到，a,b,d的顺序可以任意调整。
* =和in可以乱序，比如a=1 and b =2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会优化成索引可以识别的形式

# 锁模块

## MyISAM与InnoDB关于锁方面的区别是什么？

* MyISAM默认用的是表级锁，不支持行级锁
* InnoDB默认用的是行级锁，也支持表级锁
  * 走索引时，用行锁；不走索引时，用表锁

## MyISAM适合的场景

* 频繁执行全表count
* 对数据进行增删改的频率不高，查询非常频繁
* 没有事务

## InnoDB适合的场景

* 数据增删改查椒频繁
* 可竺性要求比较高，要求支持事务

## 锁的分类

* 按锁的粒度

  * 表级锁
  * 行级锁
  * 页级锁

* 按锁级别划分

  * 共享锁
  * 排它锁

* 按加锁方式划分

  * 自动锁

  * 显式锁

* 按操作划分

  * DML锁
  * DDL锁

* 按使用方式划分

  * 乐观锁
  * 悲观锁











