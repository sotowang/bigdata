# 如何设计一个关系型数据库

* RDBMS  
  * 程序实例
    * 存储管理
    * 缓存机制
    * SQL解析
    * 日志管理
    * 权限划分
    * 容灾机制
    * **索引管理**
    * **锁管理**
  * 存储（文件系统）
* 阶段
  * 需求分析阶段
    * 分析用户需求 
  * 概念设计阶段
    * 设计E-R图形

  * 逻辑设计阶段

      * 设计表格 
  * 物理设计阶段
    * 设计数据库的存储方式和存储路径 
  * 实现阶段 
  * 实施维护阶段

# 索引模块

## 为何要使用索引

* 避免全表扫描查找数据，提升查找效率

## 什么样的信息能成为索引？

* 主键，唯一键，普通键等让数据具备一定区分性的字段

## 索引的(类型)数据结构

* 二叉查找树
* B-Tree
  * 根节点至少包括两个孩子
  * 树中每个节点最多包含有m个孩子（m>=2）
  * 除根节点和叶节点外，其他每个节点至少有ceil(m/2)个孩子
  * 所有叶子节点都在同一层
* B+-Tree（Mysql）
  * 非叶子节点的子树指针与关键字个数相同
  * 非叶子节点的子树指针P[i],指向关键字值[K[i],K[i+1]]的子树
  * 非叶子节点仅用来索引，叶子节点存储数据
  * 所有叶子节点均有一个指针链接到下一个叶子节点
* Hash
  * 仅能满足“=”，“IN”，不能使用范围查询
  * 无法被用来避免数据的排序操作
  * 不能利用部分索引键查询
  * 不能避免表扫描
  * 遇到大量Hash值相等的情况后性能并不一定比B树索引高
* BitMap索引

## 密集索引和稀疏索引的区别

* 密集索引文件中的每个搜索码值都对应一个索引值
* 稀疏索引文件只为索引码的某些值建立索引项

## 聚簇索引和非聚簇索引的区别

* InnoDB的B+树可能存储整行数据(聚簇索引),也可能存储主键的值(非聚簇索引)
* 聚簇索引查询只用一次,非聚簇索引需要回青查询多次,通过覆盖索引也可以只查询一次
* 覆盖索引
  * 一个查询语句的执行只用从索引中就能够取得,不必从数据表中读取,称为实现了索引的覆盖,避免查到索引后回表操作,减少IO提高效率

## 定位并优化慢查询Sql

* 根据慢日志定位慢查询sql
* 使用explain等工具分析sql
* 修改sql或者尽量让sql走索引

## 查询优化器

* 一条SQL的查询可有不同执行方案,需通过优化器进行选择成本最低方案
  * 根据搜索条件,找出最有可能使用的索引
  * 计算全表扫描的代价
  * 计算使用不同索引执行查询的代价
  * 对比各种方案的代价,找出成本最低的

## 联合索引

### 最左匹配原则

* mysql索引规则中要求复合索引要想使用第二个索引，必须先使用第一个索引。（而且第一个索引必须是等值匹配）。
* mysql会一直向右匹配直到遇到范围查询（>,<,between,like）就停止匹配
  * 比如a=3 and b=4 and c>5 and d=6 
  * 如果建立（a,b,c,d）顺序的索引，d是用不到索引的
  * 如果建立（a,b,d,c）的索引，则都可以用到，a,b,d的顺序可以任意调整。
  * =和in可以乱序，比如a=1 and b =2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会优化成索引可以识别的形式
* 当创建一个联合索引时,如(key1,key2,key3),相当于他姨了(key1),(key1,key2),(key1,key2.key3)

# 锁模块

## MyISAM与InnoDB关于锁方面的区别是什么？

* MyISAM默认用的是表级锁，不支持行级锁
* InnoDB默认用的是行级锁，也支持表级锁
  * 走索引时，用行锁；不走索引时，用表锁

## MyISAM适合的场景

* 频繁执行全表count
* 对数据进行增删改的频率不高，查询非常频繁
* 没有事务

## InnoDB适合的场景

* 数据增删改查频繁
* 可靠性要求比较高，要求支持事务

## 锁的分类

* 按锁的粒度

  * 表级锁
  * 行级锁
  * 页级锁

* 按锁级别划分

  * 共享锁
  * 排它锁

* 按加锁方式划分

  * 自动锁

  * 显式锁

* 按操作划分

  * DML锁
  * DDL锁

* 按使用方式划分

  * 乐观锁
  * 悲观锁



# 事务隔离级别引起的问题

* 更新丢失
  * mysql所有事务隔离级别在数据库层面上均可避免
* 脏读
  * READ-COMMITTED事务隔离级别
* 不可重复读
* 幻读

| 事务隔离级别 | 更新丢失 | 脏读 | 不可重复读 | 幻读 |
| ------------ | -------- | ---- | ---------- | ---- |
| 未提交读     | 避免     | 发生 | 发生       | 发生 |
| 已提交读     | 避免     | 避免 | 发生       | 发生 |
| 可重复读     | 避免     | 避免 | 避免       | 发生 |
| 串行化       | 避免     | 避免 | 避免       | 避免 |

# 关键语法

* GROUP BY

  * 查询所有同学的学号，选课数，总成绩

  ```SQL
  select student_id,count(course_id),sum(score) 
  from score 
  group by student_id 
  ```

  * 查询所有同学的学号，姓名，选课数，总成绩

  ```sql
    select s.student_id,stu.name,count(s.course_id),sum(s.score) 
    from 
    	score s ,
    	student stu
    where s.student_id = stu.student_id
    group by s.student_id; 
  ```

* HAVING

  * 查询平均成绩大于60分的同学的学号和平均成绩

  ```sql
  select student_id,avg(score)
  from score
  group by student_id
  having avg(score)>60;
  ```

* 统计相关

  * COUNT
  * SUM
  * MAX
  * MIN
  * AVG

查询没有学全所有课的同学的学号，姓名

```sql
select stu.student_id,stu.name
from 
	student stu,
	score s
where stu.student_id = s.student_id
group by student_id
having count(*) <
(
    select count(*) from course
)
```





















